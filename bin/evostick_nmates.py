#!/usr/bin/python
# -*- coding: utf-8 -*-

"""
   This file belong to https://github.com/snolfi/evorobotpy
   and has been written by Stefano Nolfi, stefano.nolfi@istc.cnr.it
   requires es.py, policy.py, and evoalgo.py 
"""

import numpy as np
from numpy import zeros, dot, sqrt
import math
import time
from evoalgo import EvoAlgo
from utils import descendent_sort
import os
import sys
import configparser


# Evolve with generational
class Algo(EvoAlgo):
    def __init__(self, env, policy, seed, fileini, filedir):
        EvoAlgo.__init__(self, env, policy, seed, fileini, filedir)

    def readConfig(self):

        if os.path.isfile(self.fileini):

            config = configparser.ConfigParser()
            config.read(self.fileini)
            self.maxsteps = 1000000
            self.popSize = 100
            self.nreproducing = 20
            self.noffspring = 5
            self.mutation = 1.0#0.02
            self.elitism = True
            self.nmates = 1
            self.saveEveryN = 1
            # Parse section [ALGO]
            options = config.options("ALGO")
            for o in options:
                found = 0
                if o == "maxmsteps":
                    self.maxsteps = config.getint("ALGO","maxmsteps") * 1000000
                    found = 1
                if o == "popsize":
                    self.popSize = config.getint("ALGO","popsize")
                    found = 1
                if o == "nreproducing":
                    self.nreproducing = config.getint("ALGO","nreproducing")
                    found = 1
                if o == "mutation":
                    self.mutation = config.getfloat("ALGO","mutation")
                    found = 1
                if o == "nmates":
                    self.nmates = config.getint("ALGO","nmates")
                    found = 1
                if o == "saveeveryn":
                    self.saveEveryN = config.getint("ALGO","saveeveryn")
                    found = 1

                if found == 0:
                    print("Option %s in section [ALGO] of %s file is unknown" % (o, self.fileini))
                    sys.exit()
        else:
            print("ERROR: configuration file %s does not exist" % (self.fileini))

        # Parameters check
        assert ((self.popSize % self.nreproducing) == 0), "Inconsistent values for popSize (%d) and nreproducing (%d)".format(self.popSize, self.nreproducing)
        # Compute number of offspring generated by each reproducing individual
        self.noffspring = int(self.popSize / self.nreproducing)
        
    def savedata(self, ceval, cgen, bfit, bgfit, avefit):
        self.save()            #  save the best agent, the best postevaluated agent, and progress data across generations
        fname = os.path.join(self.filedir, "S" + str(self.seed) + ".fit")  
        fp = open(fname, "w")  # save summary
        fp.write('Seed %d (%.1f%%) gen %d msteps %d bestfit %.2f bestgfit %.2f cbestfit %.2f cbestgfit %.2f avgfit %.2f\n' %
                      (self.seed, ceval / float(self.maxsteps) * 100, cgen, ceval / 1000000, self.bestfit, self.bestgfit, bfit, bgfit, avefit))
        fp.close()

    def initPop(self):
        for i in range(self.popSize):
            self.pop[i] = self.policy.get_trainable_flat()

    def mutate(self, parent):
        child = np.zeros(self.nparams, dtype=np.float64)
        for g in range(self.nparams):
            child[g] = parent[g] + self.rg.randn()
        return child

    def reproduce(self, index):
        bestid = []
        bests = []
        for i in range(self.nreproducing):
            bestid.append(index[i])
            bests.append(self.pop[index[i]])
        # Now we must generate offspring for each reproducing individual
        for i in range(self.nreproducing):
            j = 0
            while j < self.noffspring:
                if self.elitism and j == 0:
                    # First individual to be copied is the parent
                    self.pop[(self.noffspring * i) + j] = bests[i]
                else:
                    # Mutation
                    self.pop[(self.noffspring * i) + j] = self.mutate(bests[i])
                j += 1

    def generateMates(self, ind):
        mates = []
        while len(mates) < self.nmates:
            idx = np.random.randint(0, self.popSize)
            if idx != ind:
                mates.append(idx)
        assert len(mates) == self.nmates, "Something went wrong during the generation of mates!!!"
        return mates

    def run(self):

        self.readConfig()                 # initialize hyperparameters
        start_time = time.time()                   # start time
        self.nparams = self.policy.nparams              # number of parameters
        ceval = 0                                  # current evaluation
        cgen = 0                                   # current generation
        self.rg = np.random.RandomState(self.seed) # create a random generator and initialize the seed
        self.pop = self.rg.randn(self.popSize, self.nparams) # population
        fitness = zeros(self.popSize)          # fitness
        self.stat = np.arange(0, dtype=np.float64) # initialize vector containing performance across generations
        bgfit = -99999999.0

        print("EvoStick with N-mates: seed %d maxsteps %d popSize %d mutRate %lf" % (self.seed, self.maxsteps, self.popSize, self.mutation))
        
        # Initialize population
        self.initPop()

        # main loop
        cgen = 0
        ceval = 0
        while ceval < self.maxsteps:
            # Update generation counter
            cgen += 1
            
            # If normalize=1 we update the normalization vectors
            if (self.policy.normalize == 1):
                self.policy.nn.updateNormalizationVectors()
                
            #self.env.seed(self.policy.get_seed + cgen)        # set the environment seed, it changes every generation
            self.policy.nn.seed(self.policy.get_seed + cgen)  # set the policy seed, it changes every generation
            
            # Check that the task is multi-agent and requires heterogeneity, otherwise we cannot use N-mates method
            heterogeneous = self.policy.is_heterogeneous
            assert heterogeneous == 1, "Cannot use N-mates method with homogeneous agents"
            
            # Evaluate the population
            for i in range(self.popSize):
                # Generate mates for current individual
                mates = self.generateMates(i)
                fitness[i] = 0.0
                for j in range(self.nmates):
                    self.policy.set_trainable_flat(np.concatenate((self.pop[i], self.pop[mates[j]])))
                    eval_rews, eval_length = self.policy.rollout(self.policy.ntrials)  # evaluate the individual
                    fitness[i] += eval_rews                        # update fitness
                    ceval += eval_length                          # Update the number of evaluations
                fitness[i] /= self.nmates                          # Update the number of evaluations
                self.updateBest(fitness[i], self.pop[i])           # Update data if the current offspring is better than current best  
                
            fitness, index = descendent_sort(fitness) # create an index with the ID of the individuals sorted for fitness  
            bfit = fitness[0]
                
            # Postevaluate the best individual
            if self.policy.nttrials > 0 and self.bestsol is not None:
                #self.env.seed(self.policy.get_seed + 100000)      # set the environmental seed, always the same for the same seed
                self.policy.nn.seed(self.policy.get_seed + 100000)# set the policy seed, always the same for the same seed
                self.policy.set_trainable_flat(self.pop[index[0]])     # set the parameters of the policy
                eval_rews, eval_length = self.policy.rollout(self.policy.ntrials, seed=self.policy.get_seed + 100000)
                bgfit = eval_rews
                ceval += eval_length
                self.updateBestg(bgfit, self.pop[index[0]])            # eventually update the genotype/fitness of the best post-evaluated individual   

            # Compute average fitness
            avgf = np.average(fitness)

            if ceval < self.maxsteps:
                # Reproduce
                self.reproduce(index)

            # display info
            print('Seed %d (%.1f%%) gen %d msteps %d bestfit %.2f bestgfit %.2f cbestfit %.2f cbestgfit %.2f avgfit %.2f' %
                      (self.seed, ceval / float(self.maxsteps) * 100, cgen, ceval / 1000000, self.bestfit, self.bestgfit, bfit, bgfit, avgf))

            # store data throughout generations
            self.stat = np.append(self.stat, [ceval, self.bestfit, self.bestgfit, bfit, bgfit, avgf])

            if (cgen % self.saveEveryN) == 0:
                self.savedata(ceval, cgen, bfit, bgfit, avgf) 

        self.savedata(ceval, cgen, bfit, bgfit, avgf)
        end_time = time.time()
        print('Simulation time: %dm%ds ' % (divmod(end_time - start_time, 60)))
