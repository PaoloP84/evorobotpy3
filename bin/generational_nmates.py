#!/usr/bin/python
# -*- coding: utf-8 -*-

"""
   This file belong to https://github.com/snolfi/evorobotpy
   and has been written by Stefano Nolfi, stefano.nolfi@istc.cnr.it
   requires es.py, policy.py, and evoalgo.py 
"""

import numpy as np
from numpy import zeros, dot, sqrt
import math
import time
from evoalgo import EvoAlgo
from utils import descendent_sort
import os
import sys
import configparser
import random

# Evolve with generational
class Algo(EvoAlgo):
    def __init__(self, env, policy, seed, fileini, filedir):
        EvoAlgo.__init__(self, env, policy, seed, fileini, filedir)
        self.popSize = 100

    def readConfig(self):

        if os.path.isfile(self.fileini):

            config = configparser.ConfigParser()
            config.read(self.fileini)
            self.maxsteps = 1000000
            self.popSize = 100
            self.nreproducing = 10
            self.noffspring = 10
            self.mutation = 0.02
            self.crossover = False
            self.crossrate = 0.1
            self.elitism = False
            self.nmates = 1
            self.saveEveryN = 1
            # Parse section [ALGO]
            options = config.options("ALGO")
            for o in options:
                found = 0
                if o == "maxmsteps":
                    self.maxsteps = config.getint("ALGO","maxmsteps") * 1000000
                    found = 1
                if o == "popsize":
                    self.popSize = config.getint("ALGO","popsize")
                    found = 1
                if o == "nreproducing":
                    self.nreproducing = config.getint("ALGO","nreproducing")
                    found = 1
                if o == "mutation":
                    self.mutation = config.getfloat("ALGO","mutation")
                    found = 1
                if o == "crossover":
                    cross = config.getint("ALGO","crossover")
                    self.crossover = bool(cross)
                    found = 1
                if o == "crossrate":
                    self.crossrate = config.getfloat("ALGO","crossrate")
                    found = 1
                if o == "elitism":
                    elitism = config.getint("ALGO","elitism")
                    self.elitism = bool(elitism)
                    found = 1
                if o == "nmates":
                    self.nmates = config.getint("ALGO","nmates")
                    found = 1
                if o == "saveeveryn":
                    self.saveEveryN = config.getint("ALGO","saveeveryn")
                    found = 1

                if found == 0:
                    print("Option %s in section [ALGO] of %s file is unknown" % (o, self.fileini))
                    sys.exit()
        else:
            print("ERROR: configuration file %s does not exist" % (self.fileini))

        # Parameters check
        assert ((self.popSize % self.nreproducing) == 0), "Inconsistent values for popSize (%d) and nreproducing (%d)".format(self.popSize, self.nreproducing)
        # Compute number of offspring generated by each reproducing individual
        self.noffspring = int(self.popSize / self.nreproducing)
        
    def savedata(self, ceval, cgen, bfit, bgfit, avefit):
        self.save()            #  save the best agent, the best postevaluated agent, and progress data across generations
        fname = os.path.join(self.filedir, "S" + str(self.seed) + ".fit")  
        fp = open(fname, "w")  # save summary
        fp.write('Seed %d (%.1f%%) gen %d msteps %d bestfit %.2f bestgfit %.2f cbestfit %.2f cbestgfit %.2f avgfit %.2f\n' %
                      (self.seed, ceval / float(self.maxsteps) * 100, cgen, ceval / 1000000, self.bestfit, self.bestgfit, bfit, bgfit, avefit))
        fp.close()
        
    def savePop(self):
        fname = os.path.join(self.filedir, "popS" + str(self.seed))
        np.save(fname, self.pop)
        
    def loadPop(self):
        self.pop = np.load(os.path.join(self.filedir, "popS" + str(self.seed) + ".npy"), allow_pickle=True)

    def initPop(self):
        for i in range(self.popSize):
            self.pop[i] = self.policy.get_trainable_flat()

    def mutate(self, parent):
        child = np.zeros(self.nparams, dtype=np.float64)
        for g in range(self.nparams):
            child[g] = parent[g]
            coin = self.rg.uniform(0.0, 1.0)
            if coin <= self.mutation:
                child[g] += self.rg.uniform(-self.policy.wrange, self.policy.wrange)
        return child

    def crossover(father, mother):
        # We get length from smallest individual (in case of individuals with different lengths!!!)
        ngenes = len(father)
        if len(mother) < ngenes:
            ngenes = len(mother)
        # Cross-over point is at half of the length
        point = int(ngenes / 2)
        child = np.zeros(self.nparams, dtype=np.float64)
        other_child = np.zeros(self.nparams, dtype=np.float64)
        # Fill children
        child[0:point] = father[0:point]
        other_child[0:point] = mother[0:point]
        child[point:] = mother[point:]
        other_child[point:] = father[point:]
        return child, other_child

    def reproduce(self, index):
        bestid = []
        for i in range(self.nreproducing):
            bestid.append(index[i])
            self.bests.append(self.pop[index[i]])
        coupled = np.zeros(self.popSize, dtype=bool)
        # Now we must generate offspring for each reproducing individual
        for i in range(self.nreproducing):
            j = 0
            if coupled[i]:
                j = 1 # We already copied a child from previous coupling
            while j < self.noffspring:
                if self.elitism:
                    # First individual to be copied is the parent
                    self.pop[(self.noffspring * i) + j] = self.bests[i]
                    j += 1
                else:
                    if self.crossover:
                        if not coupled[i]:
                            # Extract a random value in the range [0,1]
                            coin = self.rg.uniform(0.0, 1.0)
                            if coin <= self.crossrate:
                                # Cross-over 
                                # Look for an individual to couple with (even between those not selected for reproduction)
                                found = False
                                ind = -1
                                while not found:
                                    ind = self.rg.randint(0, self.popSize)
                                    if not coupled[ind]:
                                        found = True
                                assert ind >= 0, "Something went wrong in the while-loop, returned ind = %d!!!".format(ind)
                                # Update flags
                                coupled[i] = True
                                coupled[ind] = True
                                # We perform cross-over
                                # Depending on the index of the partner, the individual can generate either one (if the partner is within the best selected ones) or two (if the partner does not belong to the best selected individuals)
                                if ind in bestid:
                                    # One offspring for each individual
                                    self.pop[(self.noffspring * i) + j], self.pop[(self.noffspring * ind)] = self.crossover(self.bests[i], self.bests[ind]) # To be checked, it should be ok but a second check might be useful!!!! Maybe this overlaps a previously generated child!!!
                                    j += 1
                                else:
                                    self.pop[(self.noffspring * i) + j], self.pop[(self.noffspring * i) + j + 1] = self.crossover(self.bests[i], self.bests[ind])
                                    j += 2
                            else:
                                # Mutation
                                self.pop[(self.noffspring * i) + j] = self.mutate(self.bests[i])
                                j += 1
                        else:
                            # Mutation
                            self.pop[(self.noffspring * i) + j] = self.mutate(self.bests[i])
                            j += 1
                    else:
                        # Mutation
                        self.pop[(self.noffspring * i) + j] = self.mutate(self.bests[i])
                        j += 1
                        
    def generateMates(self, ind):
        mates = []
        while len(mates) < self.nmates:
            idx = np.random.randint(0, self.popSize)
            if idx != ind:
                mates.append(idx)
        assert len(mates) == self.nmates, "Something went wrong during the generation of mates!!!"
        return mates

    def run(self):

        self.readConfig()                 # initialize hyperparameters
        start_time = time.time()                   # start time
        self.nparams = self.policy.nparams              # number of parameters
        ceval = 0                                  # current evaluation
        cgen = 0                                   # current generation
        self.rg = np.random.RandomState(self.seed) # create a random generator and initialize the seed
        self.pop = self.rg.randn(self.popSize, self.nparams) # population
        fitness = zeros(self.popSize)          # fitness
        self.stat = np.arange(0, dtype=np.float64) # initialize vector containing performance across generations
        self.bests = []

        print("Generational with N-mates: seed %d maxsteps %d popSize %d mutRate %lf nMates %d" % (self.seed, self.maxsteps, self.popSize, self.mutation, self.nmates))
        
        # Initialize population
        self.initPop()

        # main loop
        cgen = 0
        ceval = 0
        while ceval < self.maxsteps:
            # Update generation counter
            cgen += 1
            
            # If normalize=1 we update the normalization vectors
            if (self.policy.normalize == 1):
                self.policy.nn.updateNormalizationVectors()
                
            #self.env.seed(self.policy.get_seed + cgen)        # set the environment seed, it changes every generation
            self.policy.nn.seed(self.policy.get_seed + cgen)  # set the policy seed, it changes every generation
            
            # Check that the task is multi-agent and requires heterogeneity, otherwise we cannot use N-mates method
            heterogeneous = self.policy.is_heterogeneous
            assert heterogeneous == 1, "Cannot use N-mates method with homogeneous agents"
            
            # Evaluate the population
            i = 0
            neval = 0
            ids = None
            while i < self.popSize:
                # Generate mates for current individual
                mates = self.generateMates(i)
                fitness[i] = 0.0
                for j in range(self.nmates):
                    self.policy.set_trainable_flat(np.concatenate((self.pop[i], self.pop[mates[j]])))
                    eval_rews, eval_length = self.policy.rollout(self.policy.ntrials)  # evaluate the individual
                    fitness[i] += eval_rews                        # update fitness
                    ceval += eval_length                          # Update the number of evaluations
                fitness[i] /= self.nmates
                self.updateBest(fitness[i], self.pop[i])           # Update data if the current offspring is better than current best  
                i += 1
                
            fitness, index = descendent_sort(fitness) # create an index with the ID of the individuals sorted for fitness  
            bfit = fitness[0]
                
            # Postevaluate the best individual
            #self.env.seed(self.policy.get_seed + 100000)      # set the environmental seed, always the same for the same seed
            self.policy.nn.seed(self.policy.get_seed + 100000) # set the policy seed, always the same for the same seed
            self.policy.set_trainable_flat(self.pop[index[0]])     # set the parameters of the policy
            eval_rews, eval_length = self.policy.rollout(self.policy.nttrials, seed=self.policy.get_seed + 100000)
            bgfit = eval_rews
            ceval += eval_length
            self.updateBestg(bgfit, self.pop[index[0]])            # eventually update the genotype/fitness of the best post-evaluated individual   

            # Compute average fitness
            avgf = np.average(fitness)

            if ceval < self.maxsteps:
                # Reproduce
                self.reproduce(index)

            # display info
            print('Seed %d (%.1f%%) gen %d msteps %d bestfit %.2f bestgfit %.2f cbestfit %.2f cbestgfit %.2f avgfit %.2f' %
                      (self.seed, ceval / float(self.maxsteps) * 100, cgen, ceval / 1000000, self.bestfit, self.bestgfit, bfit, bgfit, np.average(fitness)))

            # store data throughout generations
            self.stat = np.append(self.stat, [ceval, self.bestfit, self.bestgfit, bfit, bgfit, avgf])

            if (cgen % self.saveEveryN) == 0:
                self.savedata(ceval, cgen, bfit, bgfit, avgf) 

        self.savedata(ceval, cgen, bfit, bgfit, avgf)
        self.savePop()
        end_time = time.time()
        print('Simulation time: %dm%ds ' % (divmod(end_time - start_time, 60)))
        
    def test(self, testfile):
        if testfile is not None:
            fname = os.path.join(self.filedir, testfile)
            if (self.policy.normalize == 0):
                bestgeno = np.load(fname)
            else:
                geno = np.load(fname)
                for i in range(self.policy.ninputs * 2):
                    self.policy.normvector[i] = geno[self.policy.nparams + i]
                bestgeno = geno[0:self.policy.nparams]
                self.policy.nn.setNormalizationVectors()
        else:
            print("Useless test with no individual to be loaded...")
        # Load population
        self.loadPop()
        # Extract N different indices of mates with which the individual is evaluated
        random.seed(self.seed) # Check if useless
        mates = random.sample(range(0, self.popSize), 10) # TO BE FIXED
        # Test individual
        if (self.policy.nttrials > 0):
            ntrials = self.policy.nttrials
        else:
            ntrials = self.policy.ntrials
        avgrew = 0.0
        for i in range(10):
            self.policy.set_trainable_flat(np.concatenate((bestgeno, self.pop[mates[i]])))
            trew = 0.0
            for t in range(ntrials):
                rew, _ = self.policy.rollout(1, render=True, seed=self.policy.get_seed + 100000 + t)
                trew += rew
            trew /= float(ntrials)
            print("Reward with mate %d: %lf" % (mates[i], trew))
            avgrew += trew
        avgrew /= 10.0
        print("Average reward with 10 mates: %lf" % avgrew)
